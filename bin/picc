#!/usr/bin/env python

'''PIC microcontrollers linker.

Links several COFF objects in Microchip's PIC assembler into a single
program in the Intel HEX format.

Copyright 2016 Antonio Serrano Hernandez

This file is part of picc.

picc is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

picc is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with picc; see the file COPYING.  If not, see
<http://www.gnu.org/licenses/>.
'''

from __future__ import print_function
import argparse
import os
import subprocess
import sys

sys.path.insert(0, os.path.join(os.path.dirname(sys.argv[0]), '..'))
import picc
from picc import compiler, ar, coff, error, linker

__script__ = 'picc'
__author__ = 'Antonio Serrano Hernandez'
__copyright__ = 'Copyright (C) 2016 Antonio Serrano Hernandez'
__version__ = '0.2.2'
__license__ = 'GPL'
__maintainer__ = 'Antonio Serrano Hernandez'
__email__ = 'toni.serranoh@gmail.com'
__status__ = 'Development'
__homepage__ = 'https://github.com/aserranoh/picc'

PREPROCESS, COMPILE, ASSEMBLE, LINK = range(4)

class CompilerPipeline(object):
    def __init__(self, stop, ofile=None, include=[], verbose=False):
        self.stop = stop
        self.ofile = ofile
        self.include = include
        self.verbose = verbose
    def process(self, ifile):
        if ifile.endswith('.c'):
            self._preprocess(ifile)
        elif ifile.endswith('.i') and self.stop >= COMPILE:
            self._compile(ifile)
        elif ifile.endswith('.s') and self.stop >= ASSEMBLE:
            self._assemble(ifile)
        elif self.stop == LINK:
            self._prepare_for_link(ifile)
    def _preprocess(self, ifile):
        '''Preprocess the input file and continue to the next stages.'''
        # The preprocessing at this stage is only done if it is the last
        # stage to execute. If not, it is done together with the compilation
        # (parsing) by the pycparser module
        if self.stop == PREPROCESS:
            cmd = ['cpp']
            for path in self.include:
                cmd.append('-I')
                cmd.append(path)
            cmd.append(ifile)
            if self.ofile is not None:
                cmd.append(self.ofile)
            if self.verbose:
                print(' '.join(cmd), file=sys.stderr)
            if subprocess.call(cmd):
                sys.exit(1)
        else:
            self._compile(ifile)
    def _compile(self, ifile):
        c = compiler.Compiler(ifile, self.include)
        unit = c.compile()
        if self.stop > COMPILE:
            self._assemble(ifile)
    def _assemble(self, ifile):
        print('assembling {}'.format(ifile))
        if self.stop > ASSEMBLE:
            self._prepare_for_link(ifile)
    def _prepare_for_link(self, ifile):
        if self.stop == LINK:
            print('preparing for linking {}'.format(ifile))

def main():
    parser = argparse.ArgumentParser(prog=__script__, epilog=picc.HELP_EPILOG,
        formatter_class=argparse.RawTextHelpFormatter)
    parser.add_argument('file', nargs='+', help='Files to process')
    parser.add_argument('-c', action='store_const', dest='stop',
        const=ASSEMBLE, help='Compile and assemble, but do not link')
    parser.add_argument('-E', action='store_const', dest='stop',
        const=PREPROCESS,
        help='Preprocess only; do not compile, assemble or link')
    parser.add_argument('-I', metavar='dir', action='append', dest='include',
        help='Add <dir> to the end of the main include path')
    parser.add_argument('-o', metavar='output', dest='output',
        help='Place the output into <output>')
    parser.add_argument('-S', action='store_const', dest='stop', const=COMPILE,
        help='Compile only; do not assemble or link')
    parser.add_argument('-v', action='store_true', dest='verbose',
        help='Display the programs invoked by the compiler')
    parser.add_argument('--version', action='version',
        version=picc.VERSION_STRING)
    args = parser.parse_args()
    if args.stop is None: args.stop = LINK
    if args.include is None: args.include = []

    # If there's no input files, an error is given by parse_args.
    c = CompilerPipeline(args.stop, args.output, args.include, args.verbose)
    for f in args.file:
        c.process(f)
    '''objects = []
    try:
        for o in args.objfiles:
            f = open(o, 'rb')
            if ar.isar(f):
                objects.extend(ar.extract(f))
            else:
                objects.append(coff.readcoff(f))
            f.close()
        h = linker.link(objects)
        if not error.errors:
            h.write_hex_file(args.output)
    except IOError as ioe:
        error.fatal(ioe)'''

if __name__ == '__main__':
    main()
    exit(0 if error.errors == 0 else 1)

